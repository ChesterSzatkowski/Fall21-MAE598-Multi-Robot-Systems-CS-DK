%% MAE 598 Final Project
% Daniel Kim , Chester Szatkowski
% Fall 2021

%% Clearing
clear all;
clc;
%% Numerical Solving
species = 7;
tspan = [0 1000]; %seconds
x0 = [0.33, % initial robot population fraction
    0.33, % initial small object population fraction
    0.33, % initial large object population fraction
    0, % initial large transportation population fraction
    0, % initial small transportation population fraction
    0, % initial delivered large object population fraction
    0]; % initial delivered small object population fraction

M = readmatrix('M.txt');

alpha1 = 0.02; % rate for robots working to move a large object into transportation phase
alpha2 = 0.01; % rate for robot working to move a small object into transportation phase
alpha3 = 0.01; % rate for large object to be delivered and 4 robots to be freed
alpha4 = 0.01; % rate for small object to be delivered and a robot to be freed
alpha5 = 0.003; % rate for a robot to take 10 small objects to make a large object
beta = 0.001; % rate for robot to disassemble a large object into 10 small objects

K = [alpha1, 0, 0, 0, 0, 0, 0, 0, 0, 0;
    -alpha1, 0, 0, 0, 0, 0, 0, 0, 0, 0;
    0, 0, alpha2, 0, 0, 0, 0, 0, 0, 0;
    0, 0, -alpha2, 0, 0, 0, 0, 0, 0, 0;
    0, 0, 0, 0, alpha3, 0, 0, 0, 0, 0;
    0, 0, 0, 0, -alpha3, 0, 0, 0, 0, 0;
    0, 0, 0, 0, 0, 0, alpha4, 0, 0, 0;
    0, 0, 0, 0, 0, 0, -alpha4, 0, 0, 0;
    0, 0, 0, 0, 0, 0, 0, 0, alpha5, -beta;
    0, 0, 0, 0, 0, 0, 0, 0, -alpha5, beta];


[t,x] = ode45(@(t,x) odefun(t,x,M,K), tspan, x0);
hold on;
plot(t,x(:,1),'r'); %robots
plot(t,x(:,2),'g'); % small objects
plot(t,x(:,3),'b'); % large objects
plot(t,x(:,4),'m'); % transporting large objects
plot(t,x(:,5),'c'); % transporting small objects
plot(t,x(:,6),'y'); % delivered large object
plot(t,x(:,7),'k'); % delivered small object
legend('Robots', 'Small Objects', 'Large Objects', 'Large Transportation', 'Small Transportation', 'Delivered Large', 'Delivered Small')

%% Part C Gillespie's Method
%Code modified from Deterministic-modelling-and-stochastic-simulation-of-biochemical-pathways-using-MATLAB-2006.pdf

x0T = transpose(x0);

% D = [ -1   1   1    
%       -1   1   0    
%        1  -1  -1   
%        0   0   1 ];
D = readmatrix('D.txt');

ssz = 200;                      % system size (number of agents)
              
n0 = x0T*ssz;                   % initial number of each species

L = -D.*(D < 0);               % Stoich coeffs of the reactants
K = sum(L);                     % molecularity
c = k.*prod(factorial(L))./ssz.^(K-1);
                                     % stochastic rate constant 
tf = 500;                      % simulation stop time in seconds 
runs = 2;                       % number of realizations(simulation runs)

[ts,ns] = stoch(n0,c,D,L,tf);                   % Stochastic simulation

Vh = gma(D,k,L);                                % construct ODEs
options = odeset('refine',16);
[t,x] = ode15s(Vh,[0 tf],x0T,options);           % solve of ODEs

ns = ns./ssz;
plot(ts,ns([2, 3, 4, 5],:).');
legend('active 1','passive 1', 'active 2', 'passive 2', 'Gill active 1','Gill passive 1', 'Gill active 2', 'Gill passive 2');

%% Part D

m1 = [1 1 0 0 0 0 0]';
m2 = [0 1 1 0 0 0 0]';
m3 = [0 1 0 0 0 0 0]';
m4 = [0 0 1 0 0 0 0]';
m5 = [1 0 0 1 0 0 0]';
m6 = [0 0 0 1 1 0 0]';
m7 = [0 0 0 1 0 0 0]';
m8 = [0 0 0 0 1 0 0]';
m9 = [0 0 1 0 0 1 0]';
m10 = [0 0 0 0 1 0 1]';

R = [(m1'-m2'); (m2'-m1'); (m3'-m4'); (m4'-m3'); (m5'-m6'); (m6'-m5'); (m7'-m8'); (m8'-m7'); (m9'-m10'); (m10'-m9')];

rankR = rank(R);

%% Functions for C
function varargout = stoch(varargin)
%
% STOCH  stochastic simulation of a biochemical network
%   [Ts,Ns] = STOCH(X0,N0,K,C,D,L,TF)  performs stochastic simulation a
%   biochemical network composed of M elementary reactions, using Gillespie
%   algorithm. The input and output arguments have the following meaning:
%   
%   X0: Column vector of initial concentrations of all the species involved
%   N0: Column Vector of initial populations of all the species involved 
%   K: Row vector of rate constants of all elementary reactions
%   C: Row vector of stochastic rate constants of all elementary reactions
%   D: Stoichiometry matrix with rows correspoding to species and columns
%      corresponding to reaction channels
%   L: Stoichiometry matrix for reactants only such that L = -D.*(D < 0); 
%   TF: Final time of simulation    
%   Ts: Row vector of time points of reaction events
%   Ns: Matrix of output concentrations with a column for each time point.
% 
%   [Ts,Ns] = STOCH(X0,N0,K,C,D,L,TF,R)  performs R runs of stochastic
%   simulation. The outputs Ts and Ns are cell arrays where each cell
%   corresponds to one run. 
%  
%   [Ts,Ns,TT,NBAR] = STOCH(X0,N0,K,C,D,L,TF,R)  where R>1, also returns 
%   the ensemble of times in the row vector TT and the mean of Ns over R    
%   runs in matrix NBAR of the size of Ns.
%   
%   STOCH(X0,N0,K,C,D,L,TF,1) is the same as STOCH(X0,N0,K,C,D,L,TF).

% preliminary operations:

args = varargin;                        
if nargin<6, args{6} = 1; end           % single run by default
[n0,c,d,l,tf,runs] = args{:};           % parse inputs
oneszk = ones(size(c));
i1 = l==1;                              % reactions of type: A->B, A+B->AB
i2 = l==2;                              % reactions of type: A+A->AA
stop = tf - eps(tf);                    % simulation stop time
nOut = nargout;

% stochastic part:    

if runs < 2                                        % single run
    [yout{1:2}] = gillespie;                       % run gillispie
else                                               % multiple runs
    [tg,ng] = deal(cell(1,runs));
    for i = 1:runs, [tg{i},ng{i}] = gillespie; end % run gillispie
    yout = {tg,ng};      
    if nOut>2
        tt = unique([tg{:}]);                      % record times
        numeltt = numel(tt);                       % record populations
        nn = zeros(numel(n0), numeltt, runs);
        for i = 1:numeltt
            for j = 1:runs
                id = find(tg{j} <= tt(i),1,'last');
                nn(:,i,j) = ng{j}(:,id);
            end
        end
        yout(3:4) = {tt,mean(nn,3)};               % append population mean 
    end
end

% Output:

varargout = yout;

%   gillespie algorithm (direct method):

    function [tt,nn] = gillespie
        t = 0;                              % initial time
        n = n0;                             % initial population
        tt = [];
        nn = [];
        rand('state', sum(100*clock));      % reset random number generator
        while t <= stop
            tt = [tt t];                    % record time
            nn = [nn n];                    % record population            
            m = n(:,oneszk);                % replicate n : size(m,2) = size(k)
            b = double(~l);
            b(i1) = m(i1);                  % reactions of type: A->B, A+B->AB
            b(i2) = m(i2).*(m(i2)-1)/2;     % reactions of type: A+A->AA
            a = c.*prod(b);                 % propensity
            astr = sum(a); 
            if ~astr, break, end            % substrate utilised
            tau = -1/astr*log(rand);        % time to next reaction
            u = find(cumsum(a)>=astr*rand,1);% index of next reaction
            n = n + d(:,u);                 % update population
            t = t + tau;                    % update time
        end
        tt = [tt tf];
        nn = [nn nn(:,end)];
    end

end



function V = gma(D,k,L)
%
% Supplementary Matlab files for the paper:
%
% " Deterministic Modelling and Stochastic Simulation of Pathways using Matlab"
% by M.Ullah, H.Schmidt, K-H.Cho and O.Wolkenhauer
%
% This function implements the generalized law of mass action
%
% We would appreciate a citation if these files are used by others.

if nargin < 3
    L = -D.*(D < 0);
    i2 = L > 1;
else
    i2 = L>0 & L~=1 ;
end
i0 = L==0;
M1s = ones(size(k));
V = @Vfn;
    function xd = Vfn(t,x)          
        X = x(:,M1s);
        X(i0) = 1;
        X(i2) = X(i2).^L(i2);        
        xd = D*(k.*prod(X)).';
    end
end
function dxdt = odefun(t,x,M,K)
% x = [x(1); x(2); x(3); x(4); x(5); x(6); x(7)];
y = [4*x(1)*x(3); x(4); x(1)*x(2); x(5); x(4); 4*x(1)*x(6); x(5); x(7)*x(1); 10*x(2)*x(1); x(3)*x(1)];

dxdt = -M*K*y;
end


